# Optimal Quoting Strategy under Rate Constraints

## The Problem
Hyperliquid enforces a rate limit based on **Volume Traded**:
$$ N_{limit} = \text{Cumulative Volume (USDC)} $$
$$ \text{Constraint: } N_{requests} \le N_{limit} $$

We are currently "bankrupt" on requests (Requests > Volume), forcing us into a penalty box (0.1 Hz). To operate effectively, we must treat **API Requests as a Scarce Resource** with a tangible economic cost.

## 1. The Economics of a Request

### Resource Generation
We generate request credits by trading.
- **Organic Fills**: We earn credits equal to our order size.
  - $ \text{Credits} = \text{Size}_{order} $
- **"buying" Credits (Wash/Reloader)**: We can intentionally trade to generate credits.
  - Cost: Spread + Fees on a liquid pair (e.g., BTC/USDC).
  - Assumed Cost: ~2.5 bps (Fees) + ~1 bps (Spread) $\approx$ 3.5 bps.
  - Cost to generate 1000 credits: $1000 \times 0.00035 = \$0.35$.
  - **Shadow Price of 1 Request ($\lambda$): $\approx \$0.00035$** (0.035 cents).

### Opportunity Cost of Staling
When we *don't* update a quote, we risk "Adverse Selection" (being picked off by an arbitrageur who sees the price moved against us).
- **Cost of Stale Quote**: $ \text{Loss} = \text{Size} \times |\Delta P_{fair}| $
- We should only spend a request if the **Expected Loss** exceeds the **Shadow Price**.
$$ \text{Update Condition: } \text{Size} \times |\Delta P_{fair}| > \lambda $$

### Solving for Optimal Tolerance
$$ |\Delta P_{fair}| > \frac{\lambda}{\text{Size}} $$

**Example Scenario:**
- Order Size ($S$): $400
- Shadow Price ($\lambda$): $0.00035
- Threshold Move:
$$ \Delta P_{threshold} > \frac{0.00035}{400} = 0.000000875 \text{ (8.75 bps)} $$

**Conclusion**: We should only update our orders if the price moves by **~9 basis points** (approx 0.09%).
- For WIF ($0.40): $0.40 \times 0.0009 = 0.00036$.
- Tick Size: 0.001 (approx).
- This implies a tolerance of roughly **0.5 to 1 tick** is actually economically justified *if* we are willing to pay for requests.
- **HOWEVER**, if we are *not* paying for requests (purely organic), the Shadow Price $\lambda$ rises significantly because "running out" means the strategy stops working (infinite cost).

## 2. Adaptive "Survial" Logic

Since buying credits is a manual/secondary mechanism, the primary strategy must adapt to its **Requests Balance**.

Define **Request Budget ($B$)**:
$$ B = \text{Volume}_{cum} - \text{Requests}_{cum} $$

### State A: Wealthy ($B > 10,000$)
- We have plenty of credits.
- **Mode**: High Performance.
- **Tolerance**: 1-2 Ticks (Capture small moves).
- **Goal**: Maximize fill rate and profit.

### State B: Budget Constraint ($0 < B < 10,000$)
- Credits are tight.
- **Mode**: Conservation.
- **Tolerance**: Dilates inversely to budget.
$$ \text{Tolerance} \approx \frac{K}{B} $$
- Example: 10-50 ticks. Updates only on significant structural shifts.

### State C: Bankrupt ($B < 0$)
- current state.
- **Mode**: Survival / Penalty Box.
- **Tolerance**: Extreme (100+ ticks). Only update if price moves >5% to avoid liquidation catastrophic arb.
- **Action**: **TRIGGER RELOAD**.

## 3. The "Reload" Mechanism (Buying Requests)

Instead of nerfing the strategy permanently, we should implement a **Reloader Module**.
1. Monitor `userState`.
2. If `N_requests > N_volume * 0.9` (approaching limit):
   - Identify cheapest liquid pair (e.g., BTC, ETH).
   - Execute a Taker Buy + Taker Sell (Round trip) of size $Z$.
   - **Cost**: $\approx 3.5 \text{bps} \times Z$.
   - **Gain**: $2 \times Z$ request credits.

**Example:**
- We need 10,000 requests.
- Trade $5,000 BTC roundtrip.
- Cost: $5000 \times 0.00035 = \$1.75$.
- Result: 10,000 fresh credits. Strategy resumes High Performance mode for ~3000 seconds (at 3Hz).

## 4. Proposed Implementation Steps

1.  **Refine Configuration**: Stop using static time intervals. Use `quote_reprice_tolerance_ticks` as the primary lever.
2.  **Adaptive Engine**:
    - Query `userRateLimit` stats periodically.
    - Dynamically adjust `quote_reprice_tolerance_ticks` based on available budget.
3.  **Implement Reloader**:
    - A separate background routine (or manual trigger) to "top up" credits when low.

---
*Generated by Antigravity*
